/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "bakery.h"

static int numbers[COUNT_CLIENTS] = {0};
static int pids[COUNT_CLIENTS] = {0};


int max_number()
{
	int res = numbers[0];

	for (int i = 0; i < COUNT_CLIENTS; i++)
		if (numbers[i] > res)
			res = numbers[i];

	return res;
}

bool_t
get_number_1_svc(struct BAKERY *argp, struct BAKERY *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
	pthread_mutex_lock(&(mut[argp->ind]));
	printf("get PID=%d num=%d ind=%d\n", argp->pid, argp->num, argp->ind);
	result->num = max_number() + 1;
	numbers[argp->ind] = result->num;
	pids[argp->ind] = argp->pid;

	printf("numders: ");
	for (int i = 0; i < COUNT_CLIENTS; i++) {
		printf("%d ", numbers[i]);
	}
	printf("PID=%d num=%d ind=%d\n", argp->pid, argp->num, argp->ind);
	pthread_mutex_unlock(&mut[argp->ind]);
	return retval;
}

bool_t
serve_1_svc(struct BAKERY *argp, struct BAKERY *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
	// ждем если в массиве есть номера меньше чем argp->num
	for (int i = 0; i < COUNT_CLIENTS; i++)
	{
		int out = 1;
		while (out) {
			pthread_mutex_lock(&(mut[argp->ind]));
			out = numbers[i] != 0 && (numbers[i] < numbers[argp->ind] || 
								   numbers[i] == numbers[argp->ind] && 
								   pids[i] < pids[argp->ind]);
			pthread_mutex_unlock(&mut[argp->ind]);
		}
		// while (numbers[i] != 0 && (numbers[i] < numbers[argp->ind] || 
		// 						   numbers[i] == numbers[argp->ind] && 
		// 						   pids[i] < pids[argp->ind])) {
		// 	// printf("PID = %d, ind = %d, num = %d ", 
		// 	// 		argp->pid, argp->ind, argp->num);
		// 	// printf("i=%d, numsi=%d, numsind=%d\n", i, numbers[i], numbers[argp->ind]);
			
		// }
	}
	// printf("PID = %d, ind = %d, num = %d, op = %d, arg1 = %lf, arg2 = %lf\n", 
	// 	argp->pid, argp->ind, argp->num, argp->op, argp->arg1, argp->arg2);

	
	switch(argp->op)
	{
		case ADD:
			result->result = argp->arg1 + argp->arg2;
			break;
		case SUB:
			result->result = argp->arg1 - argp->arg2;
			break;
		case MUL:
			result->result = argp->arg1 * argp->arg2;
			break;
		case DIV:
			result->result = argp->arg1 / argp->arg2;
			break;
		default:
			break;
	}
	
	for (int i = 0; i < COUNT_CLIENTS; i++)
	{
		printf("num=%d\t%d=pid\n", numbers[i], pids[i]);
	}
	printf("PID = %d, num = %d, ind = %d, op = %d, arg1 = %lf, arg2 = %lf, res = %d\n", 
		argp->pid, argp->num, argp->ind, argp->op, argp->arg1, argp->arg2, result->result);
	
	pthread_mutex_lock(&(mut[argp->ind]));
	numbers[argp->ind] = 0;
	pids[argp->ind] = 0;
	pthread_mutex_unlock(&mut[argp->ind]);

	return retval;
}

int
bakery_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
